{"version":3,"sources":["../../../app/frontend/node_modules/safe-buffer/index.js","../../../app/frontend/node_modules/base-x/src/index.js","../../../app/frontend/node_modules/bs58/index.js","../../../app/frontend/src/app/api/checkout/sessions/route.ts","../../../app/frontend/src/app/api/checkout/complete/route.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js"],"sourcesContent":["/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","import { NextRequest, NextResponse } from \"next/server\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport {\n    createCheckoutSession,\n    getCheckoutSession,\n    updateCheckoutSession,\n    CheckoutSession,\n} from \"@/lib/db\";\n\n// Re-export CheckoutSession type for other routes\nexport type { CheckoutSession };\n\n// Legacy in-memory store for backwards compatibility during migration\n// TODO: Remove after full migration to Supabase\nconst checkoutSessions = new Map<string, CheckoutSession>();\nexport { checkoutSessions };\n\n// Generate a unique checkout session ID\nfunction generateSessionId(): string {\n    const chars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    let id = \"cs_\";\n    for (let i = 0; i < 24; i++) {\n        id += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return id;\n}\n\n// Validate Solana address\nfunction isValidSolanaAddress(address: string): boolean {\n    try {\n        new PublicKey(address);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * POST /api/checkout/sessions\n * \n * Create a new checkout session (like Stripe Checkout)\n * \n * Request body:\n * {\n *   merchantId: string,\n *   merchantName: string,\n *   merchantWallet: string,\n *   amount: number,\n *   description?: string,\n *   metadata?: Record<string, string>,\n *   successUrl: string,\n *   cancelUrl: string,\n *   webhookUrl?: string,\n *   private?: boolean  // Enable private payment (amounts encrypted on-chain)\n * }\n */\nexport async function POST(request: NextRequest) {\n    try {\n        const body = await request.json();\n\n        // Validate required fields\n        const { merchantId, merchantName, merchantWallet, amount, successUrl, cancelUrl, webhookUrl, description, metadata } = body;\n        const isPrivate = body.private === true; // Privacy mode - encrypt amounts on-chain\n\n        if (!merchantId || !merchantName || !merchantWallet || !amount || !successUrl || !cancelUrl) {\n            return NextResponse.json(\n                { error: \"Missing required fields: merchantId, merchantName, merchantWallet, amount, successUrl, cancelUrl\" },\n                { status: 400 }\n            );\n        }\n\n        if (!isValidSolanaAddress(merchantWallet)) {\n            return NextResponse.json(\n                { error: \"Invalid merchant wallet address\" },\n                { status: 400 }\n            );\n        }\n\n        if (typeof amount !== \"number\" || amount <= 0) {\n            return NextResponse.json(\n                { error: \"Amount must be a positive number\" },\n                { status: 400 }\n            );\n        }\n\n        // Create checkout session using database layer\n        const now = Date.now();\n        const expiresAt = now + 30 * 60 * 1000; // 30 minutes expiry\n\n        const session = await createCheckoutSession({\n            merchantId,\n            merchantName,\n            merchantWallet,\n            amount,\n            currency: \"USDC\",\n            description,\n            metadata,\n            successUrl,\n            cancelUrl,\n            webhookUrl,\n            expiresAt,\n            private: isPrivate,\n        });\n\n        // Also store in legacy map for backwards compatibility\n        checkoutSessions.set(session.id, session);\n\n        // Build checkout URL\n        const baseUrl = request.nextUrl.origin;\n        const checkoutUrl = `${baseUrl}/checkout/${session.id}`;\n\n        return NextResponse.json({\n            id: session.id,\n            url: checkoutUrl,\n            expiresAt: session.expiresAt,\n            status: \"pending\",\n        });\n\n    } catch (error) {\n        console.error(\"Error creating checkout session:\", error);\n        return NextResponse.json(\n            { error: \"Failed to create checkout session\" },\n            { status: 500 }\n        );\n    }\n}\n\n/**\n * GET /api/checkout/sessions?id=xxx\n * \n * Get checkout session details\n */\nexport async function GET(request: NextRequest) {\n    const sessionId = request.nextUrl.searchParams.get(\"id\");\n\n    if (!sessionId) {\n        return NextResponse.json(\n            { error: \"Session ID required\" },\n            { status: 400 }\n        );\n    }\n\n    // Try database first, then fallback to in-memory\n    let session = await getCheckoutSession(sessionId);\n\n    if (!session) {\n        // Fallback to legacy in-memory store\n        session = checkoutSessions.get(sessionId) || null;\n    }\n\n    if (!session) {\n        return NextResponse.json(\n            { error: \"Session not found\" },\n            { status: 404 }\n        );\n    }\n\n    // Check if expired\n    if (session.status === \"pending\" && Date.now() > session.expiresAt) {\n        session.status = \"expired\";\n        await updateCheckoutSession(sessionId, { status: \"expired\" });\n        checkoutSessions.set(sessionId, session);\n    }\n\n    return NextResponse.json(session);\n}\n\n// Clean up expired sessions (legacy, keep for backwards compatibility)\nfunction cleanupExpiredSessions() {\n    const now = Date.now();\n    for (const [id, session] of checkoutSessions.entries()) {\n        if (session.status === \"pending\" && now > session.expiresAt) {\n            session.status = \"expired\";\n            checkoutSessions.set(id, session);\n        }\n        // Remove sessions older than 24 hours\n        if (now - session.createdAt > 24 * 60 * 60 * 1000) {\n            checkoutSessions.delete(id);\n        }\n    }\n}\n","import { NextRequest, NextResponse } from \"next/server\";\nimport { checkoutSessions, CheckoutSession } from \"../sessions/route\";\nimport {\n    getCheckoutSession,\n    updateCheckoutSession,\n    createPayment,\n    Payment,\n} from \"@/lib/db\";\nimport { screenPaymentParties } from \"@/lib/range\";\nimport crypto from \"crypto\";\n\n/**\n * POST /api/checkout/complete\n * \n * Called after a successful payment to update session and trigger webhook\n * Includes Range Security wallet screening before completing payment\n * \n * Request body:\n * {\n *   sessionId: string,\n *   signature: string,\n *   customerWallet: string\n * }\n */\nexport async function POST(request: NextRequest) {\n    try {\n        const body = await request.json();\n        const { sessionId, signature, customerWallet } = body;\n\n        if (!sessionId || !signature || !customerWallet) {\n            return NextResponse.json(\n                { error: \"Missing required fields: sessionId, signature, customerWallet\" },\n                { status: 400 }\n            );\n        }\n\n        // Try database first, then fallback to in-memory\n        let session = await getCheckoutSession(sessionId);\n        if (!session) {\n            session = checkoutSessions.get(sessionId) || null;\n        }\n\n        if (!session) {\n            return NextResponse.json(\n                { error: \"Session not found\" },\n                { status: 404 }\n            );\n        }\n\n        if (session.status !== \"pending\") {\n            return NextResponse.json(\n                { error: `Session already ${session.status}` },\n                { status: 400 }\n            );\n        }\n\n        // Range Security: Screen both payer and merchant wallets\n        const riskScreening = await screenPaymentParties(\n            customerWallet,\n            session.merchantWallet,\n            { testMode: process.env.NODE_ENV !== 'production' }\n        );\n\n        if (!riskScreening.canProceed) {\n            console.warn(`[Range] Payment blocked: ${riskScreening.blockedParty}`, {\n                sessionId,\n                customerWallet,\n                merchantWallet: session.merchantWallet,\n                payerRisk: riskScreening.payer.summary,\n                merchantRisk: riskScreening.merchant.summary,\n            });\n\n            return NextResponse.json(\n                {\n                    error: \"Payment blocked by risk screening\",\n                    reason: riskScreening.blockedParty === 'payer'\n                        ? riskScreening.payer.summary\n                        : riskScreening.merchant.summary,\n                    blockedParty: riskScreening.blockedParty,\n                },\n                { status: 403 }\n            );\n        }\n\n        console.log(`[Range] Payment parties cleared: payer=${riskScreening.payer.riskLevel}, merchant=${riskScreening.merchant.riskLevel}`);\n\n        // Update session status\n        await updateCheckoutSession(sessionId, { status: \"completed\" });\n\n        // Also update legacy in-memory store\n        session.status = \"completed\";\n        session.paymentSignature = signature;\n        session.customerWallet = customerWallet;\n        session.completedAt = Date.now();\n        checkoutSessions.set(sessionId, session);\n\n        // Create payment record using database layer\n        const payment = await createPayment({\n            sessionId: session.id,\n            merchantId: session.merchantId,\n            merchantName: session.merchantName,\n            merchantWallet: session.merchantWallet,\n            customerWallet: customerWallet,\n            amount: session.amount,\n            currency: session.currency,\n            description: session.description,\n            metadata: session.metadata,\n            txSignature: signature,\n            explorerUrl: `https://explorer.solana.com/tx/${signature}?cluster=devnet`,\n            createdAt: session.createdAt,\n            completedAt: Date.now(),\n            status: \"completed\",\n        });\n\n        // Trigger webhook asynchronously\n        if (session.webhookUrl) {\n            triggerWebhook(session, payment.id).catch(err => {\n                console.error(\"Webhook delivery failed:\", err);\n            });\n        }\n\n        return NextResponse.json({\n            success: true,\n            paymentId: payment.id,\n            sessionId,\n            signature,\n            successUrl: session.successUrl,\n        });\n\n    } catch (error) {\n        console.error(\"Error completing checkout:\", error);\n        return NextResponse.json(\n            { error: \"Failed to complete checkout\" },\n            { status: 500 }\n        );\n    }\n}\n\n/**\n * Trigger webhook to merchant's endpoint\n */\nasync function triggerWebhook(session: CheckoutSession, paymentId: string): Promise<void> {\n    if (!session.webhookUrl) return;\n\n    const timestamp = Date.now();\n    const webhookPayload = {\n        event: \"payment.completed\",\n        data: {\n            paymentId: paymentId,\n            sessionId: session.id,\n            merchantId: session.merchantId,\n            amount: session.amount,\n            currency: session.currency,\n            customerWallet: session.customerWallet,\n            paymentSignature: session.paymentSignature,\n            description: session.description,\n            metadata: session.metadata,\n            completedAt: session.completedAt,\n            receiptUrl: `${process.env.NEXT_PUBLIC_APP_URL || 'https://settlr.io'}/receipts/${paymentId}`,\n        },\n        timestamp,\n    };\n\n    // Use merchant's webhook secret or fall back to a default\n    // In production, each merchant would have their own secret\n    const webhookSecret = process.env.SETTLR_WEBHOOK_SECRET || session.merchantId;\n    const payloadString = JSON.stringify(webhookPayload);\n    const webhookSignature = generateWebhookSignature(`${timestamp}.${payloadString}`, webhookSecret);\n\n    // Retry logic for webhook delivery\n    const maxRetries = 3;\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            const response = await fetch(session.webhookUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Settlr-Signature\": `t=${timestamp},v1=${webhookSignature}`,\n                    \"X-Settlr-Timestamp\": Date.now().toString(),\n                    \"X-Settlr-Event\": \"checkout.completed\",\n                },\n                body: JSON.stringify(webhookPayload),\n            });\n\n            if (response.ok) {\n                console.log(`Webhook delivered successfully to ${session.webhookUrl}`);\n                return;\n            }\n\n            // Log failed attempt\n            console.warn(`Webhook attempt ${attempt} failed with status ${response.status}`);\n            lastError = new Error(`HTTP ${response.status}`);\n\n        } catch (error) {\n            console.warn(`Webhook attempt ${attempt} failed:`, error);\n            lastError = error as Error;\n        }\n\n        // Wait before retry (exponential backoff)\n        if (attempt < maxRetries) {\n            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n        }\n    }\n\n    throw new Error(`Webhook delivery failed after ${maxRetries} attempts: ${lastError?.message}`);\n}\n\n/**\n * Generate HMAC-SHA256 webhook signature\n */\nfunction generateWebhookSignature(payload: string, secret: string): string {\n    return crypto\n        .createHmac(\"sha256\", secret)\n        .update(payload)\n        .digest(\"hex\");\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/frontend/src/app/api/checkout/complete/route\",\n        pathname: \"/frontend/src/app/api/checkout/complete\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/app/frontend/src/app/api/checkout/complete/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/frontend/src/app/api/checkout/complete/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,5]}